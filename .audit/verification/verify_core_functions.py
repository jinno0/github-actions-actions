#!/usr/bin/env python3
"""
Core Function Verification Script
Generated by Repo Genesis Auditor v2.0

This script verifies that the repository fulfills its stated purpose
by testing the core functions defined in intent.yml
"""

import json
import subprocess
import sys
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import Any, Optional

@dataclass
class VerificationResult:
    function_id: str
    scenario_name: str
    passed: bool
    actual_output: Any
    expected_output: Any
    error_message: Optional[str] = None
    interpretation: str = ""
    evidence_files: list = None

    def __post_init__(self):
        if self.evidence_files is None:
            self.evidence_files = []

def run_command(cmd: list, cwd: Optional[Path] = None, timeout: int = 30) -> tuple[bool, str, str]:
    """Run shell command and return (success, stdout, stderr)"""
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=cwd
        )
        return result.returncode == 0, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return False, "", "Command timed out"
    except Exception as e:
        return False, "", str(e)

def verify_cf001_review_and_merge() -> VerificationResult:
    """
    CF-001: AIによるコードレビューと自動マージが可能

    Verification: Check that review-and-merge action structure is valid
    """
    print("\n=== Verifying CF-001: review-and-merge ===")

    action_path = Path("actions/review-and-merge/action.yml")

    # Check 1: action.yml exists
    if not action_path.exists():
        return VerificationResult(
            function_id="CF-001",
            scenario_name="review-and-merge基本構造",
            passed=False,
            actual_output="action.yml not found",
            expected_output="action.yml should exist",
            error_message=f"{action_path} does not exist",
            interpretation="アクション定義ファイルが存在しない"
        )

    # Check 2: Validate YAML syntax
    success, stdout, stderr = run_command(
        ["python", "-m", "yaml", str(action_path)],
        timeout=10
    )

    if not success:
        return VerificationResult(
            function_id="CF-001",
            scenario_name="YAML構文検証",
            passed=False,
            actual_output=stderr,
            expected_output="Valid YAML",
            error_message="YAML syntax error",
            interpretation="action.ymlの構文が無効"
        )

    # Check 3: Required fields exist
    import yaml
    with open(action_path) as f:
        action_config = yaml.safe_load(f)

    required_fields = ["name", "description", "inputs"]
    missing_fields = [f for f in required_fields if f not in action_config]

    if missing_fields:
        return VerificationResult(
            function_id="CF-001",
            scenario_name="必須フィールド検証",
            passed=False,
            actual_output=f"Missing: {missing_fields}",
            expected_output=f"All fields present: {required_fields}",
            error_message=f"Missing required fields: {missing_fields}",
            interpretation="action.ymlの必須フィールドが不足"
        )

    # Check 4: Test coverage exists
    test_path = Path("tests/test_review_and_merge/test_review_action.py")
    if not test_path.exists():
        return VerificationResult(
            function_id="CF-001",
            scenario_name="テストカバーidge",
            passed=False,
            actual_output="Test file not found",
            expected_output="test_review_action.py should exist",
            interpretation="テストファイルが存在しない"
        )

    return VerificationResult(
        function_id="CF-001",
        scenario_name="review-and-merge基本構造",
        passed=True,
        actual_output={
            "action_exists": True,
            "yaml_valid": True,
            "required_fields_present": True,
            "test_exists": True
        },
        expected_output="All checks pass",
        interpretation="review-and-mergeアクションの構造が適切"
    )

def verify_cf002_spec_to_code() -> VerificationResult:
    """
    CF-002: Markdown仕様書からコードを生成可能

    Verification: Check that spec-to-code action structure is valid
    """
    print("\n=== Verifying CF-002: spec-to-code ===")

    action_path = Path("actions/spec-to-code/action.yml")

    # Check 1: action.yml exists
    if not action_path.exists():
        return VerificationResult(
            function_id="CF-002",
            scenario_name="spec-to-code基本構造",
            passed=False,
            actual_output="action.yml not found",
            expected_output="action.yml should exist",
            interpretation="アクション定義ファイルが存在しない"
        )

    # Check 2: Template files exist
    template_path = Path("actions/spec-to-code/templates/generation.txt")
    if not template_path.exists():
        return VerificationResult(
            function_id="CF-002",
            scenario_name="テンプレートファイル検証",
            passed=False,
            actual_output="Template not found",
            expected_output="generation.txt should exist",
            interpretation="生成プロンプトテンプレートが存在しない"
        )

    # Check 3: Validate YAML syntax
    success, stdout, stderr = run_command(
        ["python", "-m", "yaml", str(action_path)],
        timeout=10
    )

    if not success:
        return VerificationResult(
            function_id="CF-002",
            scenario_name="YAML構文検証",
            passed=False,
            actual_output=stderr,
            expected_output="Valid YAML",
            interpretation="action.ymlの構文が無効"
        )

    # Check 4: Test coverage exists
    test_path = Path("tests/test_spec_to_code/test_spec_to_code_action.py")
    if not test_path.exists():
        return VerificationResult(
            function_id="CF-002",
            scenario_name="テストカバレッジ",
            passed=False,
            actual_output="Test file not found",
            expected_output="test_spec_to_code_action.py should exist",
            interpretation="テストファイルが存在しない"
        )

    return VerificationResult(
        function_id="CF-002",
        scenario_name="spec-to-code基本構造",
        passed=True,
        actual_output={
            "action_exists": True,
            "yaml_valid": True,
            "template_exists": True,
            "test_exists": True
        },
        expected_output="All checks pass",
        interpretation="spec-to-codeアクションの構造が適切"
    )

def verify_cf003_action_fixer() -> VerificationResult:
    """
    CF-003: WorkflowエラーをAIが自動検知・修正可能

    Verification: Check that action-fixer structure is valid
    """
    print("\n=== Verifying CF-003: action-fixer ===")

    action_path = Path("actions/action-fixer/action.yml")

    # Check 1: action.yml exists
    if not action_path.exists():
        return VerificationResult(
            function_id="CF-003",
            scenario_name="action-fixer基本構造",
            passed=False,
            actual_output="action.yml not found",
            expected_output="action.yml should exist",
            interpretation="アクション定義ファイルが存在しない"
        )

    # Check 2: Validate YAML syntax
    success, stdout, stderr = run_command(
        ["python", "-m", "yaml", str(action_path)],
        timeout=10
    )

    if not success:
        return VerificationResult(
            function_id="CF-003",
            scenario_name="YAML構文検証",
            passed=False,
            actual_output=stderr,
            expected_output="Valid YAML",
            interpretation="action.ymlの構文が無効"
        )

    # Check 3: Template files exist
    template_path = Path("actions/action-fixer/templates/fix.txt")
    if not template_path.exists():
        return VerificationResult(
            function_id="CF-003",
            scenario_name="テンプレートファイル検証",
            passed=False,
            actual_output="Template not found",
            expected_output="fix.txt should exist",
            interpretation="修正プロンプトテンプレートが存在しない"
        )

    return VerificationResult(
        function_id="CF-003",
        scenario_name="action-fixer基本構造",
        passed=True,
        actual_output={
            "action_exists": True,
            "yaml_valid": True,
            "template_exists": True
        },
        expected_output="All checks pass",
        interpretation="action-fixerアクションの構造が適切"
    )

def verify_cf004_dry_run() -> VerificationResult:
    """
    CF-004: 全アクションがDry Runモードで検証可能

    Verification: Run pytest and check if tests pass
    """
    print("\n=== Verifying CF-004: Dry Run Testing ===")

    # Run pytest
    success, stdout, stderr = run_command(
        ["python", "-m", "pytest", "tests/", "-v", "--tb=short"],
        timeout=60
    )

    # Parse test results
    if not success:
        # Extract summary from output
        lines = stdout.split('\n')
        summary_line = [l for l in lines if 'passed' in l.lower() or 'failed' in l.lower()]

        return VerificationResult(
            function_id="CF-004",
            scenario_name="Dry Run検証",
            passed=False,
            actual_output=stdout,
            expected_output="All tests pass",
            error_message=stderr,
            interpretation=f"テストが失敗しています。\n{summary_line}",
            evidence_files=["pytest_output.txt"]
        )

    # Count tests
    import re
    match = re.search(r'(\d+) passed', stdout)
    passed_count = int(match.group(1)) if match else 0

    return VerificationResult(
        function_id="CF-004",
        scenario_name="Dry Run検証",
        passed=True,
        actual_output={
            "total_tests": passed_count,
            "all_passed": True
        },
        expected_output="All tests pass",
        interpretation=f"全{passed_count}個のテストがパスしました。Dry Run検証が機能しています。"
    )

def verify_test_coverage() -> VerificationResult:
    """
    QA-001: Verify test coverage meets the 70% threshold
    """
    print("\n=== Verifying QA-001: Test Coverage ===")

    # Read coverage.json
    coverage_path = Path("coverage.json")
    if not coverage_path.exists():
        return VerificationResult(
            function_id="QA-001",
            scenario_name="テストカバレッジ",
            passed=False,
            actual_output="coverage.json not found",
            expected_output="Coverage data should exist",
            interpretation="カバレッジデータが存在しません"
        )

    with open(coverage_path) as f:
        coverage_data = json.load(f)

    current_coverage = coverage_data["totals"]["percent_covered"]
    target_coverage = 70.0

    passed = current_coverage >= target_coverage

    return VerificationResult(
        function_id="QA-001",
        scenario_name="テストカバレッジ",
        passed=passed,
        actual_output=f"{current_coverage:.1f}%",
        expected_output=f">= {target_coverage}%",
        interpretation=(
            f"カバレッジは{current_coverage:.1f}%です。"
            f"目標値の{target_coverage}%に{'達しています' if passed else '達していません（{target_coverage - current_coverage:.1f}%不足）'}。"
        ),
        evidence_files=["coverage.json"]
    )

def main():
    """Run all core function verifications and generate report"""
    print("=" * 70)
    print("CORE FUNCTION VERIFICATION REPORT")
    print("Generated by Repo Genesis Auditor v2.0")
    print("=" * 70)

    results = [
        verify_cf001_review_and_merge(),
        verify_cf002_spec_to_code(),
        verify_cf003_action_fixer(),
        verify_cf004_dry_run(),
        verify_test_coverage(),
    ]

    # Print detailed results
    for r in results:
        status = "✅ PASS" if r.passed else "❌ FAIL"
        print(f"\n{status} [{r.function_id}] {r.scenario_name}")
        print(f"  解釈: {r.interpretation}")
        if r.error_message:
            print(f"  エラー: {r.error_message}")

    # Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)

    passed_count = sum(1 for r in results if r.passed)
    total_count = len(results)

    print(f"\nTotal: {passed_count}/{total_count} passed")

    # Core functions status
    core_functions = [r for r in results if r.function_id.startswith("CF-")]
    cf_passed = sum(1 for r in core_functions if r.passed)

    print(f"Core Functions: {cf_passed}/{len(core_functions)} passed")

    # Quality attributes status
    qa_attributes = [r for r in results if r.function_id.startswith("QA-")]
    if qa_attributes:
        qa_passed = sum(1 for r in qa_attributes if r.passed)
        print(f"Quality Attributes: {qa_passed}/{len(qa_attributes)} passed")

    # Overall verdict
    if passed_count == total_count:
        print("\n判定: ✅ リポジトリの存在意義が検証されました")
        exit_code = 0
    elif cf_passed == len(core_functions):
        print("\n判定: ⚠️ 存在意義は達成されていますが、品質属性に課題があります")
        exit_code = 0
    else:
        print("\n判定: ❌ 存在意義の一部が未達成です")
        print("\n次のアクション:")
        for r in results:
            if not r.passed:
                print(f"  - {r.function_id}: {r.interpretation}")
        exit_code = 1

    # Save results to JSON
    output_path = Path(".audit/output/verification_result.json")
    output_path.parent.mkdir(parents=True, exist_ok=True)

    results_dict = [
        {
            **asdict(r),
            "passed": r.passed,
            "actual_output": str(r.actual_output),
            "expected_output": str(r.expected_output)
        }
        for r in results
    ]

    output_path.write_text(
        json.dumps(results_dict, ensure_ascii=False, indent=2)
    )

    print(f"\n詳細なレポートを保存しました: {output_path}")

    sys.exit(exit_code)

if __name__ == "__main__":
    main()
